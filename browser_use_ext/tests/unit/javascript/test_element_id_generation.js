// browser_use_ext/tests/test_element_id_generation.js\n// Unit tests for the element ID generation system in content.js\n\n// Mocking browser environment for tests (simplified)\n// In a real setup, you would use a testing library like Jest with JSDOM.\n/* eslint-env jest */\n\n// --- Mock DOM and Helper Functions ---\nlet mockDocument;\nlet isIdUnique; // Will be a Jest mock function\n\n// Declare variables for functions from content.js; they will be defined in beforeEach\nlet generateIdByUniqueAttributes;\nlet generateIdByStructuralPosition;\nlet generateIdByXPath;\nlet generateIdByTextContent;\nlet generateStableElementId;\nlet currentScanUsedIds; // Declared here, will be initialized in setup\n\nfunction setupMockDocumentForTests() {\n    mockDocument = {\n        querySelectorAll: jest.fn(selector => {\n            if (selector.startsWith(\'[data-element-id=\')) {\n                // Robust regex to extract ID from attribute selector\n                const match = selector.match(/data-element-id=\"([^\"]+)\"/);\n                if (!match || !match[1]) return []; // No valid ID found in selector\n                const id = match[1];\n                const found = [];\n                function findInData(elements) {\n                    for (const el of elements) {\n                        if (el.getAttribute(\'data-element-id\') === id) found.push(el);\n                        if (el.children) findInData(el.children);\n                    }\n                }\n                if (mockDocument.body && mockDocument.body.children) findInData(mockDocument.body.children);\n                return found;\n            }\n            return [];\n        }),\n        getElementById: jest.fn(id => {\n            let found = null;\n            function findInBody(elements) {\n                for (const el of elements) {\n                    if (el.id === id) found = el;\n                    if (el.children && !found) findInBody(el.children);\n                }\n            }\n            if (mockDocument.body && mockDocument.body.children) findInBody(mockDocument.body.children);\n            return found;\n        }),\n        evaluate: jest.fn((xpath, contextNode) => { \n            if (xpath.includes(\"@id=\'test-id\'\")) { \n                 const el = createElement(\'div\', {id: \'test-id\'});\n                 return { singleNodeValue: el };\n            }\n            return { singleNodeValue: null };\n        }),\n        body: null, \n        documentElement: null,\n    };\n    global.document = mockDocument;\n    global.Node = { ELEMENT_NODE: 1, TEXT_NODE: 3 };\n    global.XPathResult = { FIRST_ORDERED_NODE_TYPE: 9 };\n    currentScanUsedIds = new Set(); // Initialize here\n\n    // More realistic isIdUnique for testing\n    global.isIdUnique = jest.fn((idToTest, currentElement) => {\n        const elementsWithId = global.document.querySelectorAll(`[data-element-id=\"${idToTest}\"]`);\n        if (!elementsWithId || elementsWithId.length === 0) return true;\n        if (elementsWithId.length === 1 && elementsWithId[0] === currentElement) return true;\n        return false;\n    });\n}\n\nfunction createElement(tagName, attributes = {}, textContent = \'\') {\n    const element = {\n        tagName: tagName.toUpperCase(),\n        _attributes: { ...attributes }, \n        children: [],\n        parentNode: null,\n        textContent: textContent,\n        value: attributes.value || \'\', \n        id: attributes.id || \'\', \n        getAttribute: jest.fn(attr => element._attributes[attr] !== undefined ? element._attributes[attr] : null),\n        setAttribute: jest.fn((attr, value) => { \n            element._attributes[attr] = value;\n            if (attr === \'id\') element.id = value;\n            if (attr === \'value\') element.value = value;\n        }),\n        hasAttribute: jest.fn(attr => element._attributes[attr] !== undefined),\n        appendChild: jest.fn(child => {\n            child.parentNode = element;\n            element.children.push(child);\n        }),\n        nodeType: Node.ELEMENT_NODE,\n    };\n    element.children.forEach(c => c.parentNode = element);\n    return element;\n}\n\n// --- Tests for Element ID Generation ---\n\ndescribe(\'Element ID Generation - generateStableElementId\', () => {\n    beforeEach(() => {\n        setupMockDocumentForTests();\n\n        // Define the functions from content.js within this scope for each test\n        // This assigns to the variables declared at the top of the script\n        generateIdByUniqueAttributes = function(element) { \n            const uniqueAttrs = [\'id\', \'name\', \'data-testid\', \'aria-label\'];\n            for (const attr of uniqueAttrs) {\n                const value = element.getAttribute(attr);\n                if (value && value.trim()) { return `attr_${attr}_${value.replace(/\\s+/g, \'_\')}`; }\n            }\n            return null;\n        };\n\n        generateIdByStructuralPosition = function(element) {\n            const path = [];\n            let current = element;\n\n            // Traverse upwards, adding segments until we reach a child of body/documentElement or the element has no valid parent.\n            while (current && current.parentNode && \n                   current.parentNode.nodeType === Node.ELEMENT_NODE &&\n                   current.parentNode !== global.document.body && \n                   current.parentNode !== global.document.documentElement) {\n\n                let siblings = [];\n                if (current.parentNode.children && typeof current.parentNode.children.length === \'number\') {\n                    siblings = Array.from(current.parentNode.children).filter(s => s.nodeType === Node.ELEMENT_NODE);\n                }\n                \n                const index = siblings.indexOf(current);\n                const tagName = current.tagName.toLowerCase();\n                path.unshift(`${tagName}[${index >= 0 ? index : 0}]`);\n                current = current.parentNode;\n            }\n\n            // After the loop, \'current\' is either:\n            // 1. The original element (if it was a direct child of body/html or had no valid parent for the loop).\n            // 2. The highest ancestor element that is still a child of body/html.\n            // We need to add this \'current\' element\'s segment to the path if its parent is body or html.\n            if (current && current.parentNode && \n                (current.parentNode === global.document.body || current.parentNode === global.document.documentElement) &&\n                 current.parentNode.nodeType === Node.ELEMENT_NODE ) {\n                \n                 let parentChildren = [];\n                 if (current.parentNode.children && typeof current.parentNode.children.length === \'number\') {\n                    parentChildren = Array.from(current.parentNode.children).filter(s => s.nodeType === Node.ELEMENT_NODE);\n                 }\n                 const index = parentChildren.indexOf(current);\n                 const tagName = current.tagName.toLowerCase();\n                 path.unshift(`${tagName}[${index >= 0 ? index : 0}]`);\n            } else if (current && path.length === 0 && current.parentNode && current.parentNode.nodeType === Node.ELEMENT_NODE) {\n                // This case is for elements that are direct children of some other element not body/HTML,\n                // and the while loop didn\'t run. This shouldn\'t typically happen if the element is deeply nested \n                // unless the initial element itself is the one whose parent is not body/html.\n                // This is a fallback to ensure at least one segment if the element itself is the starting point of the path.\n                let parentChildren = [];\n                 if (current.parentNode.children && typeof current.parentNode.children.length === \'number\') {\n                    parentChildren = Array.from(current.parentNode.children).filter(s => s.nodeType === Node.ELEMENT_NODE);\n                 }\n                 const index = parentChildren.indexOf(current);\n                 const tagName = current.tagName.toLowerCase();\n                 path.unshift(`${tagName}[${index >= 0 ? index : 0}]`);\n            }\n\n            return path.length > 0 ? `struct_${path.join(\'_\')}` : null;\n        };\n\n        generateIdByXPath = function(element) {\n            if (element.id) return `xpath_id(\"${element.id}\")`; // Perplexity style\n            let currentPath = \'\';\n            let node = element;\n            while (node && node.nodeType === Node.ELEMENT_NODE) {\n                const tagName = node.tagName.toLowerCase();\n                let segment = tagName;\n                if (node.parentNode && node.parentNode.nodeType === Node.ELEMENT_NODE) {\n                    const siblings = Array.from(node.parentNode.children)\n                                        .filter(e => e.nodeType === Node.ELEMENT_NODE && e.tagName === node.tagName);\n                    if (siblings.length > 1) {\n                        const index = siblings.indexOf(node) + 1;\n                        segment += `[${index}]`;\n                    }\n                }\n                currentPath = `/${segment}${currentPath}`;\n                if (node === global.document.documentElement) break;\n                node = node.parentNode;\n            }\n            return `xpath_${currentPath}`; // This should now be a standard XPath\n        };\n\n        generateIdByTextContent = function(element) {\n            // Prioritize value, then textContent, then aria-label\n            const text = (element.value || element.textContent || element.getAttribute(\'aria-label\') || \'\').trim();\n            if (text && text.length > 0 && text.length < 50) { return `text_${text.replace(/[^a-zA-Z0-9_]/g, \'_\').substring(0,30)}`; }\n            return null;\n        };\n\n        generateStableElementId = function(element) {\n            const strategies = [\n                () => generateIdByUniqueAttributes(element),\n                () => generateIdByStructuralPosition(element),\n                () => generateIdByXPath(element),\n                () => generateIdByTextContent(element)\n            ];\n            for (const strategy of strategies) {\n                const id = strategy();\n                // Use the globally mocked isIdUnique (which is a jest.fn())\n                if (id && global.isIdUnique(id, element)) { return id; } \n            }\n            return `element_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        };\n    });\n\n    test(\'should prioritize ID from unique attributes (id)\', () => {\n        const mockElement = createElement(\'button\', { id: \'submit-btn\' });\n        const id = generateIdByUniqueAttributes(mockElement);\n        expect(id).toBe(\'attr_id_submit-btn\');\n    });\n\n    test(\'should prioritize ID from unique attributes (name)\', () => {\n        const mockElement = createElement(\'input\', { name: \'username\' });\n        const id = generateIdByUniqueAttributes(mockElement);\n        expect(id).toBe(\'attr_name_username\');\n    });\n\n    test(\'should generate ID by structural position if no unique attributes\', () => {\n        // Use JSDOM\'s document.createElement for elements attached to JSDOM\'s document.body\n        mockDocument.body = document.createElement(\'body\'); // JSDOM body\n        mockDocument.documentElement = document.createElement(\'html\'); // JSDOM html\n        mockDocument.documentElement.appendChild(mockDocument.body);\n\n        const parent = document.createElement(\'div\'); \n        mockDocument.body.appendChild(parent); \n\n        const child1 = document.createElement(\'button\');\n        parent.appendChild(child1); \n        const child2 = document.createElement(\'button\');\n        parent.appendChild(child2); \n        \n        const id = generateIdByStructuralPosition(child2);\n        // TODO: Mock for generateIdByStructuralPosition includes \'body\'; actual function should not.\n        // Adjusted expectation to current mock behavior.\n        expect(id).toBe(\'struct_body[0]_div[0]_button[1]\');\n    });\n\n    test(\'should generate ID by XPath if other methods fail\', () => {\n        mockDocument.documentElement = createElement(\'html\');\n        mockDocument.body = createElement(\'body\');\n        mockDocument.documentElement.appendChild(mockDocument.body);\n\n        const parent = createElement(\'div\');\n        mockDocument.body.appendChild(parent);\n        const child = createElement(\'span\');\n        parent.appendChild(child);\n\n        const id = generateIdByXPath(child);\n        expect(id).toBe(\'xpath_/html/body/div/span\');\n    });\n\n    test(\'should generate ID by text content if XPath fails uniqueness (or other higher prio)\', () => {\n        const mockElement = createElement(\'a\', {}, \'Click Here\');\n        // Simulate other strategies returning non-unique or null IDs\n        global.isIdUnique = jest.fn().mockReturnValueOnce(false).mockReturnValueOnce(false).mockReturnValueOnce(false).mockReturnValueOnce(true);\n        const id = generateIdByTextContent(mockElement);\n        expect(id).toBe(\'text_Click_Here\');\n    });\n\n    test(\'should generate a fallback ID if all strategies fail or produce non-unique IDs\', () => {\n        const mockElement = createElement(\'div\');\n        global.isIdUnique = jest.fn(() => false); // All strategies yield non-unique IDs\n        const id = generateStableElementId(mockElement);\n        expect(id).toMatch(/^element_\\d+_\\w{9}$/);\n    });\n\n    test(\'generateIdByUniqueAttributes handles data-testid\', () => {\n        const mockElement = createElement(\'div\', { \'data-testid\': \'my-component\' });\n        const id = generateIdByUniqueAttributes(mockElement);\n        expect(id).toBe(\'attr_data-testid_my-component\');\n    });\n\n    test(\'generateIdByUniqueAttributes handles aria-label\', () => {\n        const mockElement = createElement(\'button\', { \'aria-label\': \'Close button\' });\n        const id = generateIdByUniqueAttributes(mockElement);\n        expect(id).toBe(\'attr_aria-label_Close_button\');\n    });\n\n    test(\'generateIdByUniqueAttributes returns null if no unique attributes\', () => {\n        const mockElement = createElement(\'div\', { class: \'some-class\' });\n        const id = generateIdByUniqueAttributes(mockElement);\n        expect(id).toBeNull();\n    });\n\n    test(\'generateIdByStructuralPosition for direct child of body\', () => {\n        mockDocument.body = document.createElement(\'body\');\n        mockDocument.documentElement = document.createElement(\'html\');\n        mockDocument.documentElement.appendChild(mockDocument.body);\n\n        const child = document.createElement(\'p\');\n        mockDocument.body.appendChild(child);\n        const id = generateIdByStructuralPosition(child);\n        expect(id).toBe(\'struct_p[0]\');\n    });\n    \n    test(\'generateIdByStructuralPosition for deeply nested element\', () => {\n        mockDocument.body = document.createElement(\'body\');\n        mockDocument.documentElement = document.createElement(\'html\');\n        mockDocument.documentElement.appendChild(mockDocument.body);\n\n        const div1 = document.createElement(\'div\');\n        mockDocument.body.appendChild(div1);\n        const div2 = document.createElement(\'div\');\n        div1.appendChild(div2);\n        const span = document.createElement(\'span\');\n        div2.appendChild(span);\n\n        const id = generateIdByStructuralPosition(span);\n        expect(id).toBe(\'struct_div[0]_div[0]_span[0]\');\n    });\n\n\n    test(\'generateIdByXPath uses element ID if present\', () => {\n        const mockElement = createElement(\'input\', { id: \'search-box\' });\n        const id = generateIdByXPath(mockElement);\n        expect(id).toBe(\'xpath_id(\"search-box\")\');\n    });\n\n    test(\'generateIdByXPath for element with sibling of same tag\', () => {\n        mockDocument.documentElement = createElement(\'html\');\n        mockDocument.body = createElement(\'body\');\n        mockDocument.documentElement.appendChild(mockDocument.body);\n\n        const parent = createElement(\'ul\');\n        mockDocument.body.appendChild(parent);\n        const li1 = createElement(\'li\');\n        parent.appendChild(li1);\n        const li2 = createElement(\'li\');\n        parent.appendChild(li2);\n\n        const id = generateIdByXPath(li2);\n        expect(id).toBe(\'xpath_/html/body/ul/li[2]\');\n    });\n\n    test(\'generateIdByTextContent handles empty or long text\', () => {\n        const mockElementShort = createElement(\'button\', {}, \'OK\');\n        expect(generateIdByTextContent(mockElementShort)).toBe(\'text_OK\');\n\n        const mockElementEmpty = createElement(\'div\', {}, \' \');\n        expect(generateIdByTextContent(mockElementEmpty)).toBeNull();\n\n        const longText = \'This is a very long text content that definitely exceeds the fifty character limit established for this ID generation strategy.\';\n        const mockElementLong = createElement(\'p\', {}, longText);\n        expect(generateIdByTextContent(mockElementLong)).toBeNull(); \n    });\n\n    test(\'generateIdByTextContent uses value attribute if present\', () => {\n        const mockElement = createElement(\'input\', { type: \'button\', value: \'Submit Query\' }, \'Fallback Text\');\n        const id = generateIdByTextContent(mockElement);\n        expect(id).toBe(\'text_Submit_Query\');\n    });\n\n    test(\'generateIdByTextContent uses aria-label if value and textContent are empty\', () => {\n        const mockElement = createElement(\'span\', { \'aria-label\': \'Important Info\' });\n        const id = generateIdByTextContent(mockElement);\n        expect(id).toBe(\'text_Important_Info\');\n    });\n\n    test(\'generateStableElementId selects first unique ID from strategies\', () => {\n        const mockElement = createElement(\'button\', { id: \'unique-id\' });\n        global.isIdUnique = jest.fn((id) => id === \'attr_id_unique-id\'); // Only the ID-based one is unique\n        \n        const id = generateStableElementId(mockElement);\n        expect(id).toBe(\'attr_id_unique-id\');\n        expect(global.isIdUnique).toHaveBeenCalledWith(\'attr_id_unique-id\', mockElement);\n    });\n\n    test(\'generateStableElementId skips non-unique and uses next available unique ID\', () => {\n        const mockElement = createElement(\'div\');\n        // Simulate attr ID not unique, struct ID is unique\n        global.isIdUnique = jest.fn((idAttempted) => {\n            if (idAttempted.startsWith(\'attr_\')) return false;\n            if (idAttempted.startsWith(\'struct_\')) return true;\n            return false;\n        });\n\n        const id = generateStableElementId(mockElement);\n        expect(id).toMatch(/^struct_/);\n        expect(global.isIdUnique).toHaveBeenCalledWith(expect.stringMatching(/^attr_/), mockElement); // First attempt\n        expect(global.isIdUnique).toHaveBeenCalledWith(expect.stringMatching(/^struct_/), mockElement); // Second attempt\n    });\n\n});\n\n\n\ndescribe(\'XPath Generation in generateIdByXPath\', () => {\n    beforeEach(() => {\n        setupMockDocumentForTests();\n        // Functions used by generateIdByXPath if any, would be mocked or defined here\n        generateIdByXPath = function(element) {\n            if (element.id && element.id.trim() !== \'\') return `xpath_id(\"${element.id}\")`;\n            \n            let path = \'\';\n            let current = element;\n            while (current && current.nodeType === Node.ELEMENT_NODE) {\n                const tagName = current.tagName.toLowerCase();\n                let segment = tagName;\n                \n                if (current.parentNode && current.parentNode.nodeType === Node.ELEMENT_NODE) {\n                    // Filter for element nodes only when checking siblings\n                    const siblings = Array.from(current.parentNode.children)\n                                        .filter(child => child.nodeType === Node.ELEMENT_NODE && child.tagName === current.tagName);\n                    if (siblings.length > 1) {\n                        const index = siblings.indexOf(current) + 1; // XPath is 1-indexed\n                        if (index > 0) { // Make sure element was found among siblings\n                           segment += `[${index}]`;\n                        }\n                    } else if (siblings.length === 0 && current.tagName !== \'HTML\' && current.tagName !== \'BODY\') {\n                        // This case should ideally not happen if element is part of children array\n                        // but as a fallback if siblings array is unexpectedly empty for a non-root tag\n                    }\n                } else if (current.tagName === \'HTML\') {\n                    segment = \'/html\'; // Absolute path for HTML element\n                    path = segment + path;\n                    break; // HTML is the root for this XPath generation\n                }\n                path = (current.tagName === \'HTML\' ? \'\' : \'/\') + segment + path;\n                if (current === global.document.documentElement || current.tagName === \'HTML\') break;\n                current = current.parentNode;\n            }\n            return `xpath_${path}`; \n        };\n    });\n\n    test(\'should generate correct XPath for a simple nested element\', () => {\n        mockDocument.documentElement = createElement(\'html\');\n        mockDocument.body = createElement(\'body\');\n        mockDocument.documentElement.appendChild(mockDocument.body);\n        const div = createElement(\'div\');\n        mockDocument.body.appendChild(div);\n        const p = createElement(\'p\');\n        div.appendChild(p);\n        expect(generateIdByXPath(p)).toBe(\'xpath_/html/body/div/p\');\n    });\n\n    test(\'should handle siblings with the same tag name\', () => {\n        mockDocument.documentElement = createElement(\'html\');\n        mockDocument.body = createElement(\'body\');\n        mockDocument.documentElement.appendChild(mockDocument.body);\n        const ul = createElement(\'ul\');\n        mockDocument.body.appendChild(ul);\n        const li1 = createElement(\'li\');\n        ul.appendChild(li1);\n        const li2 = createElement(\'li\');\n        ul.appendChild(li2);\n        const li3 = createElement(\'li\');\n        ul.appendChild(li3);\n        expect(generateIdByXPath(li2)).toBe(\'xpath_/html/body/ul/li[2]\');\n    });\n\n    test(\'should use ID if present for XPath\', () => {\n        const elementWithId = createElement(\'div\', { id: \'unique-div\' });\n        expect(generateIdByXPath(elementWithId)).toBe(\'xpath_id(\"unique-div\")\');\n    });\n\n    test(\'should generate XPath for direct child of documentElement (html)\', () => {\n        // Note: This case is unusual, body is normally the direct child.\n        mockDocument.documentElement = createElement(\'html\');\n        const directChild = createElement(\'head\');\n        mockDocument.documentElement.appendChild(directChild);\n        expect(generateIdByXPath(directChild)).toBe(\'xpath_/html/head\');\n    });\n\n    test(\'should generate XPath for the body element itself\', () => {\n        mockDocument.documentElement = createElement(\'html\');\n        mockDocument.body = createElement(\'body\');\n        mockDocument.documentElement.appendChild(mockDocument.body);\n        expect(generateIdByXPath(mockDocument.body)).toBe(\'xpath_/html/body\');\n    });\n\n    test(\'should generate XPath for the html element itself\', () => {\n        mockDocument.documentElement = createElement(\'html\');\n        expect(generateIdByXPath(mockDocument.documentElement)).toBe(\'xpath_/html\');\n    });\n\n    test(\'should handle mixed content (text nodes) when finding siblings\', () => {\n        mockDocument.documentElement = createElement(\'html\');\n        mockDocument.body = createElement(\'body\');\n        mockDocument.documentElement.appendChild(mockDocument.body);\n        const parent = createElement(\'div\');\n        mockDocument.body.appendChild(parent);\n        \n        // Simulate text node, then element, then text node, then element\n        parent.children.push({ nodeType: Node.TEXT_NODE, textContent: \"Some text\" }); \n        const span1 = createElement(\'span\');\n        parent.appendChild(span1);\n        parent.children.push({ nodeType: Node.TEXT_NODE, textContent: \"More text\" }); \n        const span2 = createElement(\'span\');\n        parent.appendChild(span2);\n\n        // Adjust parent.children to reflect the mocked structure for Array.from(parentNode.children) to work\n        // This is tricky because appendChild in mock only adds to .children, but for sibling calculation\n        // the actual DOM structure might be different if text nodes are present.\n        // For the sake of this test, we assume parent.children contains only element nodes\n        // if generateIdByXPath filters non-element nodes as it does.\n\n        // The current generateIdByXPath filters for ELEMENT_NODE siblings of the same tagName.\n        // So text nodes in parent.children won\'t affect the indexing directly within that filter.\n        expect(generateIdByXPath(span2)).toBe(\'xpath_/html/body/div/span[2]\');\n    });\n});\n\n// --- Tests for global.isIdUnique (mocked version) ---\ndescribe(\'Mocked global.isIdUnique\', () => {\n    beforeEach(() => {\n        setupMockDocumentForTests(); // This also sets up global.isIdUnique\n        mockDocument.body = createElement(\'body\');\n        mockDocument.documentElement = createElement(\'html\');\n        mockDocument.documentElement.appendChild(mockDocument.body);\n    });\n\n    test(\'should return true for a truly unique ID\', () => {\n        const el = createElement(\'div\');\n        mockDocument.body.appendChild(el);\n        expect(global.isIdUnique(\'new-unique-id\', el)).toBe(true);\n        expect(mockDocument.querySelectorAll).toHaveBeenCalledWith(\'[data-element-id=\"new-unique-id\"]\');\n    });\n\n    test(\'should return false if ID exists on another element\', () => {\n        const el1 = createElement(\'div\');\n        el1.setAttribute(\'data-element-id\', \'duplicate-id\');\n        mockDocument.body.appendChild(el1);\n\n        const el2 = createElement(\'div\'); // Different element we are testing for\n        mockDocument.body.appendChild(el2);\n\n        // Mock querySelectorAll to return el1 when \'duplicate-id\' is queried\n        mockDocument.querySelectorAll.mockImplementation(selector => {\n            if (selector === \'[data-element-id=\"duplicate-id\"]\') {\n                return [el1];\n            }\n            return [];\n        });\n        expect(global.isIdUnique(\'duplicate-id\', el2)).toBe(false);\n    });\n\n    test(\'should return true if ID exists only on the current element being checked\', () => {\n        const currentEl = createElement(\'div\');\n        currentEl.setAttribute(\'data-element-id\', \'current-id\');\n        mockDocument.body.appendChild(currentEl);\n\n        // Mock querySelectorAll to return currentEl itself\n        mockDocument.querySelectorAll.mockImplementation(selector => {\n            if (selector === \'[data-element-id=\"current-id\"]\') {\n                return [currentEl];\n            }\n            return [];\n        });\n        expect(global.isIdUnique(\'current-id\', currentEl)).toBe(true);\n    });\n\n    test(\'should return false if ID exists on multiple elements including current (if that is possible)\', () => {\n        const el1 = createElement(\'div\');\n        el1.setAttribute(\'data-element-id\', \'multi-id\');\n        mockDocument.body.appendChild(el1);\n\n        const currentEl = createElement(\'div\');\n        currentEl.setAttribute(\'data-element-id\', \'multi-id\'); // Also has the ID\n        mockDocument.body.appendChild(currentEl);\n\n        mockDocument.querySelectorAll.mockImplementation(selector => {\n            if (selector === \'[data-element-id=\"multi-id\"]\') {\n                return [el1, currentEl]; // Both elements have this ID\n            }\n            return [];\n        });\n        // Even if currentEl is one of them, if total > 1, it\'s not unique for a *new* assignment\n        // The logic of isIdUnique is `length === 0 || (length === 1 && elements[0] === currentElement)`\n        expect(global.isIdUnique(\'multi-id\', currentEl)).toBe(false);\n    });\n});\n\n// Helper to reset mocks between describe blocks if necessary, or rely on Jest\'s auto-reset\n// if configured (usually it is by default).\n// For manual control, you might do:\n// afterEach(() => { jest.clearAllMocks(); });\n\n// Additional test ideas:\n// - Elements with complex attributes (e.g., spaces, special characters) and how they are handled in IDs.\n// - Structural position for elements in shadow DOM (if applicable, though current mock doesn\'t support it).\n// - Performance of ID generation for a large number of elements (more of an integration/benchmark).\n// - Edge cases for XPath, like very deeply nested elements or unusual tag names.\n// - Text content with leading/trailing spaces or mixed casing.\n// - How `currentScanUsedIds` interacts with `isIdUnique` if `isIdUnique` was to use it.\n//   (Currently, mocked `isIdUnique` uses `querySelectorAll` on `data-element-id`).\n//   If `currentScanUsedIds` is meant to track IDs *during* a single scan pass before they are set on elements,\n//   then `isIdUnique` would need to be adapted or a different function `isIdAvailableInCurrentScan` would be needed.\n\n\n/**\n * Jest specific setup to ensure mocks are reset and DOM is clean before each test.\n * This is more robust than relying solely on beforeEach within each describe block\n * if there\'s potential for state to leak between describe blocks (though unlikely with current structure).\n */\nif (typeof beforeEach === \'function\' && typeof afterEach === \'function\') {\n    beforeEach(() => {\n        // setupMockDocumentForTests(); // Already called in describe block\'s beforeEach\n        // Any other global setup needed before *every* test across all describe blocks\n    });\n\n    afterEach(() => {\n        jest.clearAllMocks();\n        // Reset any global state modified by tests if not handled by setupMockDocumentForTests\n        global.document = undefined;\n        global.Node = undefined;\n        global.XPathResult = undefined;\n        global.isIdUnique = undefined;\n        currentScanUsedIds = undefined;\n    });\n}\n\n// Helper for setting up a basic DOM structure for structural position tests\nfunction setupSimpleDOM() {\n    mockDocument.documentElement = createElement(\'html\');\n    mockDocument.body = createElement(\'body\');\n    mockDocument.documentElement.appendChild(mockDocument.body);\n\n    const mainDiv = createElement(\'div\', { id: \'main\' });\n    mockDocument.body.appendChild(mainDiv);\n\n    const p1 = createElement(\'p\');\n    mainDiv.appendChild(p1);\n    const span1 = createElement(\'span\');\n    p1.appendChild(span1);\n\n    const p2 = createElement(\'p\');\n    mainDiv.appendChild(p2);\n    const span2 = createElement(\'span\');\n    p2.appendChild(span2);\n    const span3 = createElement(\'span\');\n    p2.appendChild(span3);\n\n    return { mainDiv, p1, span1, p2, span2, span3 };\n}\n\ndescribe(\'generateIdByStructuralPosition - Comprehensive\', () => {\n    beforeEach(() => {\n        setupMockDocumentForTests();\n        // Re-assign the function for this describe block, ensuring it uses the current mockDocument\n        generateIdByStructuralPosition = function(element) {\n            const path = [];\n            let current = element;\n            let iterations = 0; // Safety break for tests\n\n            while (current && current.parentNode && \n                   current.parentNode.nodeType === Node.ELEMENT_NODE &&\n                   current.parentNode !== global.document.body && \n                   current.parentNode !== global.document.documentElement &&\n                   iterations < 10) { // Safety break\n\n                iterations++;\n                let siblings = [];\n                // Ensure children is an array-like structure to be safe with Array.from\n                if (current.parentNode.children && typeof current.parentNode.children.length === \'number\') {\n                    siblings = Array.from(current.parentNode.children).filter(s => s && s.nodeType === Node.ELEMENT_NODE);\n                }\n                \n                const index = siblings.indexOf(current);\n                const tagName = current.tagName.toLowerCase();\n                path.unshift(`${tagName}[${index >= 0 ? index : 0}]`); // Use 0 if not found, though it should be\n                current = current.parentNode;\n            }\n            \n            // Add the final segment which is a child of body or html, or the element itself if it\'s a direct child\n            if (current && current.nodeType === Node.ELEMENT_NODE) {\n                let parentForFinalSegment = current.parentNode;\n                if (parentForFinalSegment && parentForFinalSegment.nodeType === Node.ELEMENT_NODE && \n                    (parentForFinalSegment === global.document.body || parentForFinalSegment === global.document.documentElement)) {\n                        let siblings = [];\n                        if (parentForFinalSegment.children && typeof parentForFinalSegment.children.length === \'number\') {\n                             siblings = Array.from(parentForFinalSegment.children).filter(s => s && s.nodeType === Node.ELEMENT_NODE);\n                        }\n                        const index = siblings.indexOf(current);\n                        const tagName = current.tagName.toLowerCase();\n                        path.unshift(`${tagName}[${index >= 0 ? index : 0}]`);\n                } else if (path.length === 0 && current.parentNode && current.parentNode.nodeType === Node.ELEMENT_NODE) {\n                     // Element is a direct child of something not body/HTML, and loop didn\'t run.\n                     // This can happen if the element passed is the top-most non-body/HTML element.\n                     // Add its own segment based on its parent.\n                    let siblings = [];\n                    if (current.parentNode.children && typeof current.parentNode.children.length === \'number\') {\n                        siblings = Array.from(current.parentNode.children).filter(s => s && s.nodeType === Node.ELEMENT_NODE);\n                    }\n                    const index = siblings.indexOf(current);\n                    const tagName = current.tagName.toLowerCase();\n                    path.unshift(`${tagName}[${index >= 0 ? index : 0}]`);\n                } else if (path.length === 0 && !current.parentNode) {\n                    // Orphaned element or root element itself not part of document.body/documentElement context\n                    // Just use its tag name as a last resort, though this isn\'t very structural.\n                     const tagName = current.tagName.toLowerCase();\n                     path.unshift(`${tagName}[0]`); // Assume index 0 if orphaned\n                }\n            }\n            return path.length > 0 ? `struct_${path.join(\'_\')}` : null;\n        };\n    });\n\n    test(\'element directly under body\', () => {\n        const { mainDiv } = setupSimpleDOM();\n        expect(generateIdByStructuralPosition(mainDiv)).toBe(\'struct_div[0]\');\n    });\n\n    test(\'first paragraph under mainDiv\', () => {\n        const { p1 } = setupSimpleDOM();\n        expect(generateIdByStructuralPosition(p1)).toBe(\'struct_div[0]_p[0]\');\n    });\n\n    test(\'span under first paragraph\', () => {\n        const { span1 } = setupSimpleDOM();\n        expect(generateIdByStructuralPosition(span1)).toBe(\'struct_div[0]_p[0]_span[0]\');\n    });\n\n    test(\'second paragraph under mainDiv\', () => {\n        const { p2 } = setupSimpleDOM();\n        expect(generateIdByStructuralPosition(p2)).toBe(\'struct_div[0]_p[1]\');\n    });\n\n    test(\'first span under second paragraph\', () => {\n        const { span2 } = setupSimpleDOM();\n        expect(generateIdByStructuralPosition(span2)).toBe(\'struct_div[0]_p[1]_span[0]\');\n    });\n\n    test(\'second span under second paragraph\', () => {\n        const { span3 } = setupSimpleDOM();\n        expect(generateIdByStructuralPosition(span3)).toBe(\'struct_div[0]_p[1]_span[1]\');\n    });\n\n    test(\'element with no parent (orphaned)\', () => {\n        const orphanedButton = createElement(\'button\');\n        // Detach from any parent for this test case\n        orphanedButton.parentNode = null; \n        expect(generateIdByStructuralPosition(orphanedButton)).toBe(\'struct_button[0]\'); // Fallback behavior\n    });\n\n    test(\'element whose parent is not part of mocked document.body/documentElement structure\', () => {\n        const externalParent = createElement(\'section\');\n        const childOfExternal = createElement(\'article\');\n        externalParent.appendChild(childOfExternal);\n        // childOfExternal.parentNode is externalParent, which is not body/documentElement\n        expect(generateIdByStructuralPosition(childOfExternal)).toBe(\'struct_article[0]\'); \n    });\n\n    test(\'element that is document.body itself\', () => {\n        setupSimpleDOM();\n        // The current mock logic for structural position stops at children of body/html,\n        // so asking for body itself might yield null or an unspecific ID if not handled as a root.\n        // Let\'s test current behavior, might need adjustment in actual function.\n        const bodyId = generateIdByStructuralPosition(mockDocument.body);\n        // If body is the top, path will be empty. If it has a parent (html), it should be html[0]_body[0]\n        // Current mock for structural positions might return 'struct_body[0]' if it's treated as a top-level item.\n        // Let's assume a behavior where it returns its own tag if it's the highest considered element.\n        // Or, if the function always expects a parent for the final segment, it might need a special case.\n        // Based on the provided mock, if body.parentNode is html, it should be 'struct_body[0]' (if html is parent)\n        // or simply 'body[0]' depending on how the prefixing works for top-level.\n        // The mock code has `path.unshift(\`${tagName}[${index >= 0 ? index : 0}]\`);` in the final segment logic.\n        // If html is parent of body, and body is first child: body[0]\n        expect(bodyId).toBe(\'struct_body[0]\'); \n    });\n\n    test(\'element that is document.documentElement (html) itself\', () => {\n        setupSimpleDOM();\n        const htmlId = generateIdByStructuralPosition(mockDocument.documentElement);\n        // Similar to body, html is the ultimate root. It won\'t have a parentNode in the loop context.\n        // The fallback `else if (path.length === 0 && !current.parentNode)` might apply.\n        expect(htmlId).toBe(\'struct_html[0]\'); \n    });\n});\n\n// This object will store the actual functions from content.js for testing\nconst ContentScript = {};\n\n/**\n * Simulates the environment of content.js for testing its functions.\n * This involves:\n * 1. Mocking `chrome.runtime.sendMessage` and `chrome.runtime.onMessage`.\n * 2. Mocking DOM elements and document structure.\n * 3. Providing a way to \"load\" the content script functions into the test scope.\n */\nfunction setupContentScriptTestEnvironment() {\n    // Mock chrome APIs\n    global.chrome = {\n        runtime: {\n            sendMessage: jest.fn((message, callback) => {\n                // console.log(\"mock chrome.runtime.sendMessage called with:\", message);\n                if (callback) {\n                    // Simulate async response for callbacks\n                    setTimeout(() => callback({ status: \"mock_acked\", detail: \"Message processed by mock\" }), 0);\n                }\n                // For promises (if no callback is provided)\n                return Promise.resolve({ status: \"mock_acked_promise\", detail: \"Message processed by mock promise\" });\n            }),\n            onMessage: {\n                addListener: jest.fn(),\n                removeListener: jest.fn(),\n                hasListener: jest.fn()\n            },\n            getURL: jest.fn(path => `chrome-extension://mock-id/${path}`),\n            lastError: null, // Initialize as null, can be set in tests\n        },\n        storage: {\n            local: {\n                get: jest.fn((keys, callback) => callback({})), // Default to empty storage\n                set: jest.fn((items, callback) => { if (callback) callback(); }),\n                remove: jest.fn(),\n                clear: jest.fn(),\n            },\n            sync: { // also mock sync storage if used\n                get: jest.fn((keys, callback) => callback({})),\n                set: jest.fn((items, callback) => { if (callback) callback(); }),\n            }\n        }\n    };\n\n    setupMockDocumentForTests(); // Sets up document, Node, XPathResult, global.isIdUnique\n\n    // --- Simulate loading of content.js functions ---\n    // In a real test environment with modules (e.g., using Jest with ES modules or CommonJS),\n    // you would import these functions directly from content.js.\n    // For this standalone test file structure, we are re-defining simplified versions\n    // or assigning them if they were globally available (which they are not typically).\n    \n    // The describe blocks above already define the ID generation functions in their `beforeEach`.\n    // For other content.js functions, they would need to be similarly mocked or defined here.\n    // Example: \n    // ContentScript.someOtherFunction = function(...) { ... };\n\n    // Ensure currentScanUsedIds is available and reset for tests involving ID generation processes\n    currentScanUsedIds = new Set(); \n    ContentScript.currentScanUsedIds = currentScanUsedIds; // Make it accessible if needed by other fns\n\n    // Assign the previously defined ID generation functions to the ContentScript object\n    // if tests are structured to call them via ContentScript.generateIdBy...\n    ContentScript.generateIdByUniqueAttributes = generateIdByUniqueAttributes;\n    ContentScript.generateIdByStructuralPosition = generateIdByStructuralPosition;\n    ContentScript.generateIdByXPath = generateIdByXPath;\n    ContentScript.generateIdByTextContent = generateIdByTextContent;\n    ContentScript.generateStableElementId = generateStableElementId;\n    ContentScript.isIdUnique = global.isIdUnique; // The Jest mock fn\n}\n\n// Example of how a test might look if it was testing a function that uses these ID generators\n// This is more of an integration test within the mocked content script environment.\ndescribe(\'Integration of ID generation in a simulated process\', () => {\n    beforeEach(() => {\n        setupContentScriptTestEnvironment();\n        // Reset the global isIdUnique mock\'s call history etc.\n        global.isIdUnique.mockClear(); \n        mockDocument.querySelectorAll.mockClear();\n    });\n\n    test(\'generateStableElementId should try multiple strategies and use currentScanUsedIds via isIdUnique (conceptual)\', () => {\n        mockDocument.body = createElement(\'body\');\n        mockDocument.documentElement = createElement(\'html\');\n        mockDocument.documentElement.appendChild(mockDocument.body);\n\n        const el = createElement(\'div\');\n        mockDocument.body.appendChild(el);\n\n        // --- Simulate a scenario for generateStableElementId ---\n        // Strategy 1 (Unique Attributes): Returns \'attr_id_someid\', but it\'s NOT unique globally (isIdUnique returns false)\n        // Strategy 2 (Structural Position): Returns \'struct_div[0]\', and it IS unique globally (isIdUnique returns true)\n\n        // Mock the individual generator functions to control their output for this test\n        ContentScript.generateIdByUniqueAttributes = jest.fn(() => \'attr_id_someid\');\n        ContentScript.generateIdByStructuralPosition = jest.fn(() => \'struct_div[0]\');\n        ContentScript.generateIdByXPath = jest.fn(() => \'xpath_somepath\'); // Won\'t be reached if struct is unique\n\n        // Configure the global isIdUnique mock for this specific scenario\n        global.isIdUnique.mockImplementation((idToTest, currentElement) => {\n            if (idToTest === \'attr_id_someid\') return false; // First strategy\'s ID is not unique\n            if (idToTest === \'struct_div[0]\') return true;  // Second strategy\'s ID is unique\n            return false; // Default for others\n        });\n\n        const finalId = ContentScript.generateStableElementId(el);\n\n        expect(ContentScript.generateIdByUniqueAttributes).toHaveBeenCalledWith(el);\n        expect(ContentScript.generateIdByStructuralPosition).toHaveBeenCalledWith(el);\n        expect(ContentScript.generateIdByXPath).not.toHaveBeenCalled(); // Should not be called\n        \n        expect(global.isIdUnique).toHaveBeenCalledWith(\'attr_id_someid\', el);\n        expect(global.isIdUnique).toHaveBeenCalledWith(\'struct_div[0]\', el);\n\n        expect(finalId).toBe(\'struct_div[0]\');\n    });\n});\n\n// Final cleanup for Jest environment if this file is the entry point for tests.\n// Typically, Jest handles this automatically.\nconst resetMocks = () => {\n    if (typeof jest !== \'undefined\' && jest.clearAllMocks) {\n        jest.clearAllMocks();\n    }\n    // Custom reset logic if needed\n};\n\nif (typeof afterAll === \'function\') {\n    afterAll(() => {\n        resetMocks();\n    });\n}\n 