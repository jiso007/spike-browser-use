// browser_use_ext/tests/test_state_handler.js\n// Unit tests for the updated state handling in content.js\n\n/* eslint-env jest */\n\n// --- Mock DOM and Helper Functions ---\nlet mockDocument;\nlet detectActionableElements;\nlet handleGetState;\n\n// Minimal mock element creation\nfunction createMockElement(tagName, attributes = {}, textContent = \'\', children = []) {\n    const element = {\n        tagName: tagName.toUpperCase(),\n        _attributes: { ...attributes },\n        textContent: textContent,\n        style: { display: \'block\', visibility: \'visible\', opacity: \'1\' }, // For isElementVisible checks\n        children: [],\n        parentNode: null,\n        // Needed for isElementVisible & getBoundingClientRect in mocks\n        getBoundingClientRect: jest.fn(() => ({\n            width: attributes._mockWidth !== undefined ? attributes._mockWidth : 100,\n            height: attributes._mockHeight !== undefined ? attributes._mockHeight : 50,\n            top: 10, left: 10, bottom: 60, right: 110\n        })),\n        // Basic attribute functions\n        getAttribute: jest.fn(attr => element._attributes[attr] !== undefined ? element._attributes[attr] : null),\n        setAttribute: jest.fn((attr, value) => { element._attributes[attr] = value; }),\n        querySelectorAll: jest.fn(() => []), // For total_elements count\n        appendChild: jest.fn(child => {\n            child.parentNode = element;\n            element.children.push(child);\n        }),\n        nodeType: 1, // Node.ELEMENT_NODE\n    };\n    children.forEach(child => element.appendChild(child));\n    return element;\n}\n\nfunction setupMockEnvironmentForState() {\n    mockDocument = {\n        title: \'Mock Page Title\',\n        body: createMockElement(\'body\'), \n        querySelectorAll: jest.fn(() => []), \n    };\n    global.document = mockDocument;\n\n    // Store original window properties if they exist, to restore later if needed (though Jest usually handles this)\n    const originalWindowLocation = global.window ? global.window.location : undefined;\n\n    global.window = {}; // Start with a fresh window object for each test setup\n\n    // Robustly mock window.location\n    let currentHref = \'http://mock.example.com\'; // Default for tests\n    Object.defineProperty(global.window, \'location\', {\n        value: {\n            get href() { return currentHref; },\n            set href(val) { currentHref = val; },\n            // Add other location properties if needed by content.js, e.g., assign: jest.fn(), reload: jest.fn()\n        },\n        writable: true, // Allow tests to further modify/spy on parts of location if necessary\n        configurable: true\n    });\n    \n    // Define other window properties directly on the new global.window\n    global.window.innerWidth = 1280;\n    global.window.innerHeight = 720;\n    global.window.scrollX = 0;\n    global.window.scrollY = 50;\n    global.window.getComputedStyle = jest.fn(element => ({\n        display: element.style.display || \'block\',\n        visibility: element.style.visibility || \'visible\',\n        opacity: element.style.opacity || \'1\'\n    }));\n\n    detectActionableElements = jest.fn().mockReturnValue([]); \n\n    handleGetState = async function(requestId) {\n        try {\n            const actionableElements = detectActionableElements(); // Uses the mock\n            const pageState = {\n                url: global.window.location.href,\n                title: global.document.title,\n                viewport: {\n                    width: global.window.innerWidth,\n                    height: global.window.innerHeight\n                },\n                scroll_position: {\n                    x: global.window.scrollX,\n                    y: global.window.scrollY\n                },\n                actionable_elements: actionableElements,\n                page_metrics: {\n                    total_elements: global.document.body.querySelectorAll(\'*\').length, // Mocked qSA\n                    actionable_count: actionableElements.length,\n                    visible_count: actionableElements.filter(el => el.is_visible).length // Relies on is_visible in mock data\n                },\n                timestamp: new Date().toISOString()\n            };\n            return {\n                request_id: requestId,\n                type: \"response\",\n                status: \"success\",\n                data: pageState\n            };\n        } catch (error) {\n            return {\n                request_id: requestId,\n                type: \"response\",\n                status: \"error\",\n                error: `Content script error during get_state: ${error.message}`\n            };\n        }\n    };\n}\n\n// --- Tests for State Handler ---\n\ndescribe(\'State Handler - handleGetState\', () => {\n    beforeEach(() => {\n        setupMockEnvironmentForState();\n    });\n\n    test(\'should return basic page state information correctly\', async () => {\n        const mockActionableElement = {\n            id: \'btn-123\', type: \'button\', tag: \'button\', text_content: \'Submit\',\n            attributes: { class: \'primary\' }, is_visible: true, available_operations: [\'click\']\n        };\n        detectActionableElements.mockReturnValue([mockActionableElement]);\n        \n        global.window.location.href = \'http://mock.example.com\'; \n        global.document.title = \'Mock Page Title\'; // Explicitly set title for this test\n\n        // Explicitly set a new Jest mock for querySelectorAll on the body for this test\n        global.document.body.querySelectorAll = jest.fn().mockReturnValue({ length: 50 });\n\n        const requestId = \'state-req-1\';\n        const response = await handleGetState(requestId);\n\n        expect(response.request_id).toBe(requestId);\n        expect(response.type).toBe(\'response\');\n        expect(response.status).toBe(\'success\');\n        expect(response.data.url).toBe(\'http://mock.example.com\');\n        expect(response.data.title).toBe(\'Mock Page Title\');\n        expect(response.data.viewport).toEqual({ width: 1280, height: 720 });\n        expect(response.data.scroll_position).toEqual({ x: 0, y: 50 });\n        expect(response.data.actionable_elements).toHaveLength(1);\n        expect(response.data.actionable_elements[0]).toEqual(mockActionableElement);\n        expect(response.data.page_metrics.total_elements).toBe(50);\n        expect(response.data.page_metrics.actionable_count).toBe(1);\n        expect(response.data.page_metrics.visible_count).toBe(1);\n        expect(response.data.timestamp).toBeDefined();\n    });\n\n    test(\'should handle case with no actionable elements\', async () => {\n        detectActionableElements.mockReturnValue([]); \n        \n        global.window.location.href = \'http://someother.url/forthiscase\';\n\n        // Explicitly set a new Jest mock for querySelectorAll on the body for this test\n        global.document.body.querySelectorAll = jest.fn().mockReturnValue({ length: 20 });\n\n        const response = await handleGetState(\'state-req-2\');\n        expect(response.status).toBe(\'success\');\n        expect(response.data.actionable_elements).toHaveLength(0);\n        expect(response.data.page_metrics.actionable_count).toBe(0);\n        expect(response.data.page_metrics.visible_count).toBe(0);\n        expect(response.data.page_metrics.total_elements).toBe(20);\n    });\n\n    test(\'should correctly count visible elements among actionable ones\', async () => {\n        const elements = [\n            { id: \'el1\', is_visible: true },\n            { id: \'el2\', is_visible: false },\n            { id: \'el3\', is_visible: true },\n        ];\n        detectActionableElements.mockReturnValue(elements);\n        const response = await handleGetState(\'state-req-3\');\n        expect(response.data.page_metrics.actionable_count).toBe(3);\n        expect(response.data.page_metrics.visible_count).toBe(2);\n    });\n\n    test(\'should return error status if detectActionableElements throws\', async () => {\n        const errorMessage = \"Detection failed badly!\";\n        detectActionableElements.mockImplementation(() => {\n            throw new Error(errorMessage);\n        });\n\n        const response = await handleGetState(\'state-req-error\');\n        expect(response.status).toBe(\'error\');\n        expect(response.error).toContain(errorMessage);\n    });\n\n    test(\'should include a valid ISO timestamp\', async () => {\n        const response = await handleGetState(\'state-req-ts\');\n        expect(response.status).toBe(\'success\');\n        const parsedDate = new Date(response.data.timestamp);\n        expect(parsedDate).toBeInstanceOf(Date);\n        expect(isNaN(parsedDate.getTime())).toBe(false);\n    });\n}); 